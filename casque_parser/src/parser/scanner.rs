use crate::parser::{Input, ParserResult};
use nom::{
    bytes::complete::tag,
    branch::alt,
    character::complete::{alpha1, alphanumeric1, char, digit1, none_of, one_of},
    combinator::{recognize, verify},
    multi::many0,
    sequence::{preceded, delimited}
};

const KEYWORDS: &[&str; 2] = &["true", "false"];

pub fn ident(input: Input) -> ParserResult<Input> {
    verify(
        recognize(
            preceded(
                alt((alpha1, tag("_"))),
                many0(alt((alphanumeric1, tag("_"))))
            )
        ),
        |ident: &str| !KEYWORDS.iter().any(|kw| &ident == kw)
    )(input)
}

pub fn number(input: Input) -> ParserResult<Input> {
    recognize(
        preceded(digit1, many0(alt((tag("_"), digit1))))
    )(input)
}

pub fn character(input: Input) -> ParserResult<Input> {
    delimited(
        char('\''),
        alt((
            recognize(preceded(char('\\'), one_of("nt\\'"))),
            // or just any single character
            recognize(none_of("\\'"))
        )),
        char('\'')
    )(input)
}

pub fn boolean(input: Input) -> ParserResult<Input> {
    alt((tag("true"), tag("false")))(input)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::nom_error;

    parser_tests! {
        ident_test: ident {
            "abc" => Ok(("", "abc"));
            "a_b_c" => Ok(("", "a_b_c"));
            "abc_123" => Ok(("", "abc_123"));
            "_abc" => Ok(("", "_abc"));
            "123abc" => nom_error("123abc", nom::error::ErrorKind::Tag);
        }

		number_test: number {
			"123" => Ok(("", "123"));
			"12_345" => Ok(("", "12_345"));
			"12a" => Ok(("a", "12"));
			"a12" => Err(nom::Err::Error(nom::error::Error {
				input: "a12",
				code: nom::error::ErrorKind::Digit
			}));
		}

		character_test: character {
			"'a'" => Ok(("", "a"));
			"'\\n'" => Ok(("", "\\n"));
            "'\\t'" => Ok(("", "\\t"));
            "'\\''" => Ok(("", "\\'"));
            "'\\\\'" => Ok(("", "\\\\"));
			"\"a\"" => nom_error("\"a\"", nom::error::ErrorKind::Char);
		}

		bool_test: boolean {
			"true" => Ok(("", "true"));
			"false" => Ok(("", "false"));
		}

		// Ensure that keywords aren't parsed as identifiers
		keyword_test: ident {
            "true" => nom_error("true", nom::error::ErrorKind::Verify);
            "false" => nom_error("false", nom::error::ErrorKind::Verify);
        }
    }
}

macro_rules! simple_token {
    ($name:ident $lexeme:expr) => {
        pub fn $name(input: Input) -> ParserResult<Input> {
            tag($lexeme)(input)
        }
    };
}

// Simple tokens generated by `simple_token_gen.tgo`
simple_token!(colon ":");
simple_token!(double_colon "::");
simple_token!(open_paren "(");
simple_token!(close_paren ")");
simple_token!(comma ",");
simple_token!(arrow "->");
simple_token!(eq "=");
simple_token!(q_mark "?");
simple_token!(double_bar "||");
simple_token!(double_amp "&&");
simple_token!(bar "|");
simple_token!(carot "^");
simple_token!(amp "&");
simple_token!(double_eq "==");
simple_token!(bang_eq "!=");
simple_token!(gt ">");
simple_token!(lt "<");
simple_token!(gt_eq ">=");
simple_token!(lt_eq "<=");
simple_token!(double_gt ">>");
simple_token!(double_lt "<<");
simple_token!(plus "+");
simple_token!(minus "-");
simple_token!(star "*");
simple_token!(slash "/");
simple_token!(percent "%");
simple_token!(bang "!");
simple_token!(tilde "~");

#[cfg(test)]
mod simple_tests {
    use super::*;

    parser_tests! {
            colon_test: colon { ":" => Ok(("", ":")); }
            double_colon_test: double_colon { "::" => Ok(("", "::")); }
            open_paren_test: open_paren { "(" => Ok(("", "(")); }
            close_paren_test: close_paren { ")" => Ok(("", ")")); }
            comma_test: comma { "," => Ok(("", ",")); }
            arrow_test: arrow { "->" => Ok(("", "->")); }
            eq_test: eq { "=" => Ok(("", "=")); }
            q_mark_test: q_mark { "?" => Ok(("", "?")); }
            double_bar_test: double_bar { "||" => Ok(("", "||")); }
            double_amp_test: double_amp { "&&" => Ok(("", "&&")); }
            bar_test: bar { "|" => Ok(("", "|")); }
            carot_test: carot { "^" => Ok(("", "^")); }
            amp_test: amp { "&" => Ok(("", "&")); }
            double_eq_test: double_eq { "==" => Ok(("", "==")); }
            bang_eq_test: bang_eq { "!=" => Ok(("", "!=")); }
            gt_test: gt { ">" => Ok(("", ">")); }
            lt_test: lt { "<" => Ok(("", "<")); }
            gt_eq_test: gt_eq { ">=" => Ok(("", ">=")); }
            lt_eq_test: lt_eq { "<=" => Ok(("", "<=")); }
            double_gt_test: double_gt { ">>" => Ok(("", ">>")); }
            double_lt_test: double_lt { "<<" => Ok(("", "<<")); }
            plus_test: plus { "+" => Ok(("", "+")); }
            minus_test: minus { "-" => Ok(("", "-")); }
            star_test: star { "*" => Ok(("", "*")); }
            slash_test: slash { "/" => Ok(("", "/")); }
            percent_test: percent { "%" => Ok(("", "%")); }
            bang_test: bang { "!" => Ok(("", "!")); }
            tilde_test: tilde { "~" => Ok(("", "~")); }
    }
}
